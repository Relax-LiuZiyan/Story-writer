---
title: ESP8266-12F 物联网学习
tags: 'ESP8266,物联网,嵌入式'
slug: storywriter/grammar
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_decorate: false
grammar_attrs: false
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
[toc]

# ESP8266程序下载
## flash布局
本设计采用无操作系统进行编程测试，使用不支持云端升级的non-FOTA固件。

![flash布局 Non-FOTA](./images/1655775923894.png)

## 下载地址
由于该开发板外部Flash容量为4096KB，也就是4MB，由于读写必须是扇区为单位进行操作，扇区上图说明中可以得到为4KB，因此最该开发板最后一个扇区地址为0X3FF000，因此采用对应下图的下载地址。

![固件下载地址](./images/1655776175296.png)
## ESP8266 Download Tool
烧录程序时，如果处于等待同步模式，则需要切换ESP8266从程序运行模式到程序下载模式中。

![烧录固件地址与配置选择](./images/1655776590816.png)

当板子引脚GPIO0为低电平时为串口下载模式，根据原理图可知，BOOT按键按下后，系统进入下载模式，因此等待程序下载，默认情况下，引脚接高电平则为程序运行模式。


![下载按键同步](./images/1655776900809.png)
# sdk编程—程序架构

![EPS8266—SDK编程](./images/1655777984965.png)

![回调函数](./images/1655778038610.png)

![任务函数和中断函数](./images/1655778056390.png)
# UART编程

![串口API接口](./images/1655781250071.png)

![串口配置](./images/1655781147935.png)
代码中需要注意的一点是，os_printf用的是系统串口打印，波特率为74880，而uart0_sendStr波特率为串口初始化函数配置。

``` c?linenums
user_init(void)
{
	uart_init(BIT_RATE_9600, BIT_RATE_9600);
	os_printf("\r\n--------------------------------------------\r\n");
	os_printf("SDK	version:	%s	\r\n",	system_get_sdk_version()); //串口打印SDK版本信息
	uart0_sendStr("\r\nHello World!\r\n");
	os_printf("\r\n--------------------------------------------\r\n");
}
```


![串口信息打印界面](./images/1655781321015.png)
# Makefile
如果修改代码文件对应的路径，则需要进行makefile的编译修改，具体过程参考。
[【物联网教程】基于ESP8266(WIFI) - P14 物联网教程_14_MakeFile](https://www.bilibili.com/video/BV1dJ411S723?p=14&vd_source=85143ebef149f78ad6d9c01fb85eb64b)

# Watch Dog

![watch dog 描述](./images/1655781919066.png)
如果不执行`system_soft_wdt_feed`函数，则系统会进行不断重启复位，因此需要进行经常喂狗保持系统稳定。

``` c?linenums
void ICACHE_FLASH_ATTR user_init(void)
{
	uart_init(115200,115200);	// 初始化串口波特率
	os_delay_us(10000);			// 等待串口稳定
	os_printf("\r\n=================================================\r\n");
	os_printf("\t Project:\t%s\r\n", ProjectName);
	os_printf("\t SDK version:\t%s", system_get_sdk_version());
	os_printf("\r\n=================================================\r\n");
	while(1)
	{
		system_soft_wdt_feed();		// 喂狗，防止复位
	}
}
```

# Delay 系统延时函数

添加了了 ICACHE_FLASH_ATTR 的代码通常⽐比使⽤用 IRAM_ATTR 标记的代码执⾏行行得慢。然而，像⼤大多数嵌入式平台⼀样， ESP8266 的 iRAM 空间有限，因此建议⼀般代码添加ICACHE_FLASH_ATTR，仅对执⾏行行效率要求⾼高的代码添加 IRAM_ATTR宏。

``` c?linenums
#include "user_interface.h"
#include "osapi.h"

// 毫秒延时函数(不要延时太久)
//===========================================
void ICACHE_FLASH_ATTR delay_ms(u32 C_time)
{	for(;C_time>0;C_time--)
	{ os_delay_us(1000);}
}

```

![系统毫秒延时函数](./images/1655795440864.png)
# GPIO_Output
根据原理图控制LED灯亮，则需要配置GPIO4为低电平，根据乐鑫的技术文档2.2章GPIO寄存器说明，需要先将GPIO4配置为GPIO功能，代码为第11行。

``` c?linenums
void ICACHE_FLASH_ATTR user_init(void)
{
	u8 F_LED = 0 ;		// LED状态标志位
	uart_init(115200,115200);	// 初始化串口波特率
	os_delay_us(10000);			// 等待串口稳定
	os_printf("\r\n=================================================\r\n");
	os_printf("\t Project:\t%s\r\n", ProjectName);
	os_printf("\t SDK version:\t%s", system_get_sdk_version());
	os_printf("\r\n=================================================\r\n");

	// 管脚功能选择(注意：参数1【PIN_NAME】管脚名、参数2【FUNC】管脚功能)
	//--------------------------------------------------------------------------
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO4_U,	FUNC_GPIO4);	// GPIO4设为IO口

	// 将相应管脚设为输出模式，并输出对应电平(参数1【gpio_no】、参数2：输出电平)
	//--------------------------------------------------------------------------
	GPIO_OUTPUT_SET(GPIO_ID_PIN(4),1);			// IO4 = 1(高电平)

	// 注意：【PIN_NAME】、【FUNC】、【gpio_no】不要混淆
	//…………………………………………………………………………………………………
	//·【PIN_NAME】		管脚名称		"PERIPHS_IO_MUX_" + "管脚名"
	//·【FUNC】			管脚功能		功能序号 - 1
	//·【gpio_no】			IO端口序号		GPIO_ID_PIN(IO端口序号)
	//…………………………………………………………………………………………………

	while(1)
	{
		system_soft_wdt_feed();					// 喂狗，防止复位
		F_LED = !F_LED;							// LED状态值翻转
		GPIO_OUTPUT_SET(GPIO_ID_PIN(4),F_LED);	// 设置LED(IO4)输出值
		delay_ms(500);							// 延时500Ms
	}
}
```

PIN_FUNC_SELECT函数是将引脚配置为对应功能，管脚引脚名前缀为`PERIPHS_IO_MUX_`，后面为具体引脚名称，对面引脚宏下面为功能。

![PIN_FUNC_SELECT函数说明](./images/1655810991718.png)
配置好GPIO4引脚后，将GPIO4引脚输出高电平即可输出对应电平。

# GPIO_Input
根据原理图可知GPIO0引脚与按键连接，由于存在外部上拉，因此按键按下时为低电平，没按下则为高电平。因此可以通过读取引脚电平变换得到按键是否按下的信息。

``` c?linenums
void ICACHE_FLASH_ATTR user_init(void)
{
	uart_init(115200,115200);	// 初始化串口波特率
	os_delay_us(10000);			// 等待串口稳定
	os_printf("\r\n=================================================\r\n");
	os_printf("\t Project:\t%s\r\n", ProjectName);
	os_printf("\t SDK version:\t%s", system_get_sdk_version());
	os_printf("\r\n=================================================\r\n");

	// 初始化LED(注意【PIN_NAME】、【FUNC】、【gpio_no】不要混淆)
	//-------------------------------------------------------------------------
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO4_U,	FUNC_GPIO4);	// GPIO_4设为IO口
	GPIO_OUTPUT_SET(GPIO_ID_PIN(4),1);						// GPIO_4 = 1

	// 初始化按键(BOOT == GPIO0)
	//----------------------------------------------------------------------------------
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U,	FUNC_GPIO0);	// GPIO_0设为IO口
	GPIO_DIS_OUTPUT(GPIO_ID_PIN(0));						// GPIO_0失能输出(默认)
	PIN_PULLUP_DIS(PERIPHS_IO_MUX_GPIO0_U);					// GPIO_0失能内部上拉(默认)
//	PIN_PULLUP_EN(PERIPHS_IO_MUX_GPIO0_U);					// GPIO_0使能内部上拉

	while(1)
	{
		system_soft_wdt_feed();								// 喂狗，防止复位
		if( GPIO_INPUT_GET(GPIO_ID_PIN(0)) == 0 )			// 读取GPIO_0电平
			GPIO_OUTPUT_SET(GPIO_ID_PIN(4),0);				// LED亮
		else
			GPIO_OUTPUT_SET(GPIO_ID_PIN(4),1);				// LED灭
	}
}
```

17行是将GPIO0引脚配置为GPIO功能，然后关闭引脚输出功能和内部上拉，通过判断电平判断按键是否按下。

# GPIO_EXTI



![GPIO中断寄存器](./images/1655883452589.png)


``` c?linenums
// user_init：entry of user application, init user function here
//==========================================================================================
void ICACHE_FLASH_ATTR user_init(void)
{
	uart_init(115200,115200);	// 初始化串口波特率
	os_delay_us(10000);			// 等待串口稳定
	os_printf("\r\n=================================================\r\n");
	os_printf("\t Project:\t%s\r\n", ProjectName);
	os_printf("\t SDK version:\t%s", system_get_sdk_version());
	os_printf("\r\n=================================================\r\n");

	// 初始化LED(注意【PIN_NAME】、【FUNC】、【gpio_no】不要混淆)
	//-------------------------------------------------------------------------
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO4_U,	FUNC_GPIO4);	// GPIO_4设为IO口
	GPIO_OUTPUT_SET(GPIO_ID_PIN(4),1);						// GPIO_4 = 1

	// 初始化按键(BOOT == GPIO0)
	//-----------------------------------------------------------------------------
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U,	FUNC_GPIO0);	// GPIO_0作为GPIO口
	GPIO_DIS_OUTPUT(GPIO_ID_PIN(0));						// GPIO_0失能输出(默认)
//	PIN_PULLUP_DIS(PERIPHS_IO_MUX_GPIO0_U);					// GPIO_0失能上拉(默认)
//	PIN_PULLUP_EN(PERIPHS_IO_MUX_GPIO0_U);					// GPIO_0使能上拉

	// GPIO_0中断设置
	//----------------------------------------------------------------------------------
	ETS_GPIO_INTR_DISABLE();										// 关闭GPIO中断功能
	ETS_GPIO_INTR_ATTACH((ets_isr_t)GPIO_INTERRUPT,NULL);			// 注册中断回调函数
	gpio_pin_intr_state_set(GPIO_ID_PIN(0),GPIO_PIN_INTR_NEGEDGE);	// GPIO_0下降沿中断
	ETS_GPIO_INTR_ENABLE();											// 打开GPIO中断功能

	//…………………………………………………………
    // GPIO_PIN_INTR_DISABLE = 0,	// 不触发中断
    // GPIO_PIN_INTR_POSEDGE = 1,	// 上升沿中断
    // GPIO_PIN_INTR_NEGEDGE = 2,	// 下降沿中断
    // GPIO_PIN_INTR_ANYEDGE = 3,	// 双边沿中断
    // GPIO_PIN_INTR_LOLEVEL = 4,	// 低电平中断
    // GPIO_PIN_INTR_HILEVEL = 5	// 高电平中断
	//…………………………………………………………
}
```

通过寄存器`GPIO_STATUS_ADDRESS`读取当前的引脚中断状态，由于是GPIO0按键连接按键，按键按下后触发中断，此时`S_GPIO_INT`数值为`0x01`，通过对`GPIO_STATUS_W1TC_ADDRESS`寄存器对应引脚位置写入1，清楚中断标志位。

``` c?linenums
// GPIO中断函数【注意：中断函数前不要有"ICACHE_FLASH_ATTR"宏】
//=============================================================================
void GPIO_INTERRUPT(void)
{
	u32	S_GPIO_INT;		// 所有IO口的中断状态
	u32 F_GPIO_0_INT;	// GPIO_0的中断状态

	// 读取GPIO中断状态
	S_GPIO_INT = GPIO_REG_READ(GPIO_STATUS_ADDRESS);

	// 清除中断状态位(如果不清除状态位，则会持续进入中断)
	GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, S_GPIO_INT);
	
	// 判断引脚位置0是否为1，获取GPIO_0中断状态
	F_GPIO_0_INT = S_GPIO_INT & (0x01<<0);	

	// 判断是否是KEY中断(未做消抖)
	if(F_GPIO_0_INT)	// GPIO_0的下降沿中断
	{
		F_LED = !F_LED;
		GPIO_OUTPUT_SET(GPIO_ID_PIN(4),F_LED);	// LED状态翻转
	}
}
```

# OS_Timer

![软件定时器描述](./images/1655888273088.png)

``` c?linenums
// 注：OS_Timer_1必须定义为全局变量，因为ESP8266的内核还要使用
//--------------------------------------------------------------------
os_timer_t OS_Timer_1;	// ①：定义软件定时器(os_timer_t型结构体)

// 软件定时的回调函数
//======================================================================
void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)		// ②：定义回调函数
{
	F_LED = !F_LED;
	GPIO_OUTPUT_SET(GPIO_ID_PIN(4),F_LED);		// LED状态翻转


	os_printf("\r\n----OS_Timer_1_cb----\r\n");	// 进入回调函数标志
}
//======================================================================


// 软件定时器初始化(ms毫秒)
//================================================================================================
void ICACHE_FLASH_ATTR OS_Timer_1_Init_JX(u32 time_ms, u8 time_repetitive)
{
	// 关闭定时器
	// 参数一：要关闭的定时器
	//--------------------------------------------------------
	os_timer_disarm(&OS_Timer_1);	// ③：关闭软件定时器

	// 设置定时器
	// 参数一：要设置的定时器；参数二：回调函数(需类型转换)；参数三：回调函数的参数
	//【注：os_timer_setfn必须在软件定时器未使能的情况下调用】
	//------------------------------------------------------------------------------------------
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);	// ④：设置回调函数

	// 使能(启动)ms定时器
	// 参数一：要使能的定时器；参数二：定时时间（单位：ms）；参数三：1=重复/0=只一次
	//------------------------------------------------------------------------------------------
	os_timer_arm(&OS_Timer_1, time_ms, time_repetitive);  // ⑤：设置定时器参数并使能定时器
	//-------------------------------------------------------------------
	// 【如未调用system_timer_reinit，可支持范围：[5ms ～ 6,870,947ms]】
	// 【如果调用system_timer_reinit，可支持范围：[100ms ～ 428,496 ms]】
	//-------------------------------------------------------------------
}
```

# sprintf无法使用

![报错信息](./images/1655798402167.png)

![无法使用的原因](./images/1655798350052.png)
由于使用sprintf函数，对数据进行字符转换导致的问题，解决办法为使用ESP8266 IDE提供的API接口函数os_sprintf即可解决，形参一致。

``` c?linenums
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define printf(...) os_printf( __VA_ARGS__ )
#define sprintf(...) os_sprintf( __VA_ARGS__ )

void GPIO_INTERRUPT(void)
{
	u32	S_GPIO_INT;		// 所有IO口的中断状态
	u32 F_GPIO_0_INT;	// GPIO_0的中断状态
	char str[50] = {0};

	// 读取GPIO中断状态
	//---------------------------------------------------
	S_GPIO_INT = GPIO_REG_READ(GPIO_STATUS_ADDRESS);

	sprintf(str, "S_GPIO_INT = [%X]\r\n",S_GPIO_INT);
	uart0_sendStr(str);

	// 清除中断状态位(如果不清除状态位，则会持续进入中断)
	//----------------------------------------------------
	GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, S_GPIO_INT);

	F_GPIO_0_INT = S_GPIO_INT & (0x01<<0);	// 获取GPIO_0中断状态

	sprintf(str, "F_GPIO_0_INT = [%X]\r\n",F_GPIO_0_INT);
	uart0_sendStr(str);

	// 判断是否是KEY中断(未做消抖)
	//------------------------------------------------------------
	if(F_GPIO_0_INT)	// GPIO_0的下降沿中断
	{
		F_LED = !F_LED;
		GPIO_OUTPUT_SET(GPIO_ID_PIN(4),F_LED);	// LED状态翻转
	}
}

```

参考链接：
1. [USAGE OF <STDIO.H> (PRINTF, SPRINTF)](https://www.esp8266.com/viewtopic.php?f=28&t=2173)
2. [小白学ESP8266遇到问题，请大佬帮忙](https://bbs.csdn.net/topics/394689453)
 
# 原理图

![schmatic](./images/Schematic_物联网开发板-ESP8266_2022-06-21.png)