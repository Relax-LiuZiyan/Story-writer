---
title: ESP8266-12F 物联网项目学习
tags: 'ESP8266,物联网,嵌入式'
slug: storywriter/grammar
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_decorate: false
grammar_attrs: false
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
[toc]

# ESP8266程序下载
## flash布局
本设计采用无操作系统进行编程测试，使用不支持云端升级的non-FOTA固件。

![flash布局 Non-FOTA](./images/1655775923894.png)

## 下载地址
由于该开发板外部Flash容量为4096KB，也就是4MB，由于读写必须是扇区为单位进行操作，扇区上图说明中可以得到为4KB，因此最该开发板最后一个扇区地址为0X3FF000，因此采用对应下图的下载地址。

![固件下载地址](./images/1655776175296.png)
## ESP8266 Download Tool
烧录程序时，如果处于等待同步模式，则需要切换ESP8266从程序运行模式到程序下载模式中。

![烧录固件地址与配置选择](./images/1655776590816.png)

当板子引脚GPIO0为低电平时为串口下载模式，根据原理图可知，BOOT按键按下后，系统进入下载模式，因此等待程序下载，默认情况下，引脚接高电平则为程序运行模式。


![下载按键同步](./images/1655776900809.png)
# sdk编程—程序架构

![EPS8266—SDK编程](./images/1655777984965.png)

![回调函数](./images/1655778038610.png)

![任务函数和中断函数](./images/1655778056390.png)
# UART编程

![串口API接口](./images/1655781250071.png)

![串口配置](./images/1655781147935.png)
代码中需要注意的一点是，os_printf用的是系统串口打印，波特率为74880，而uart0_sendStr波特率为串口初始化函数配置。

``` c?linenums
user_init(void)
{
	uart_init(BIT_RATE_9600, BIT_RATE_9600);
	os_printf("\r\n--------------------------------------------\r\n");
	os_printf("SDK	version:	%s	\r\n",	system_get_sdk_version()); //串口打印SDK版本信息
	uart0_sendStr("\r\nHello World!\r\n");
	os_printf("\r\n--------------------------------------------\r\n");
}
```


![串口信息打印界面](./images/1655781321015.png)
# Makefile
如果修改代码文件对应的路径，则需要进行makefile的编译修改，具体过程参考。
[【物联网教程】基于ESP8266(WIFI) - P14 物联网教程_14_MakeFile](https://www.bilibili.com/video/BV1dJ411S723?p=14&vd_source=85143ebef149f78ad6d9c01fb85eb64b)

# Watch Dog

![watch dog 描述](./images/1655781919066.png)
如果不执行`system_soft_wdt_feed`函数，则系统会进行不断重启复位，因此需要进行经常喂狗保持系统稳定。

``` c?linenums
void ICACHE_FLASH_ATTR user_init(void)
{
	uart_init(115200,115200);	// 初始化串口波特率
	os_delay_us(10000);			// 等待串口稳定
	os_printf("\r\n=================================================\r\n");
	os_printf("\t Project:\t%s\r\n", ProjectName);
	os_printf("\t SDK version:\t%s", system_get_sdk_version());
	os_printf("\r\n=================================================\r\n");
	while(1)
	{
		system_soft_wdt_feed();		// 喂狗，防止复位
	}
}
```

# Delay 系统延时函数

添加了了 ICACHE_FLASH_ATTR 的代码通常⽐比使⽤用 IRAM_ATTR 标记的代码执⾏行行得慢。然而，像⼤大多数嵌入式平台⼀样， ESP8266 的 iRAM 空间有限，因此建议⼀般代码添加ICACHE_FLASH_ATTR，仅对执⾏行行效率要求⾼高的代码添加 IRAM_ATTR宏。

``` c?linenums
#include "user_interface.h"
#include "osapi.h"

// 毫秒延时函数(不要延时太久)
//===========================================
void ICACHE_FLASH_ATTR delay_ms(u32 C_time)
{	for(;C_time>0;C_time--)
	{ os_delay_us(1000);}
}

```

![系统毫秒延时函数](./images/1655795440864.png)

# sprintf无法使用

![报错信息](./images/1655798402167.png)

![无法使用的原因](./images/1655798350052.png)
由于使用sprintf函数，对数据进行字符转换导致的问题，解决办法为使用ESP8266 IDE提供的API接口函数os_sprintf即可解决，形参一致。

``` c?linenums
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define printf(...) os_printf( __VA_ARGS__ )
#define sprintf(...) os_sprintf( __VA_ARGS__ )

void GPIO_INTERRUPT(void)
{
	u32	S_GPIO_INT;		// 所有IO口的中断状态
	u32 F_GPIO_0_INT;	// GPIO_0的中断状态
	char str[50] = {0};

	// 读取GPIO中断状态
	//---------------------------------------------------
	S_GPIO_INT = GPIO_REG_READ(GPIO_STATUS_ADDRESS);

	sprintf(str, "S_GPIO_INT = [%X]\r\n",S_GPIO_INT);
	uart0_sendStr(str);

	// 清除中断状态位(如果不清除状态位，则会持续进入中断)
	//----------------------------------------------------
	GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, S_GPIO_INT);

	F_GPIO_0_INT = S_GPIO_INT & (0x01<<0);	// 获取GPIO_0中断状态

	sprintf(str, "F_GPIO_0_INT = [%X]\r\n",F_GPIO_0_INT);
	uart0_sendStr(str);

	// 判断是否是KEY中断(未做消抖)
	//------------------------------------------------------------
	if(F_GPIO_0_INT)	// GPIO_0的下降沿中断
	{
		F_LED = !F_LED;
		GPIO_OUTPUT_SET(GPIO_ID_PIN(4),F_LED);	// LED状态翻转
	}
}

```

参考链接：

[USAGE OF <STDIO.H> (PRINTF, SPRINTF)](https://www.esp8266.com/viewtopic.php?f=28&t=2173)
# 原理图

![enter description here](./images/Schematic_物联网开发板-ESP8266_2022-06-21.png)